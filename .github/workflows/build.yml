name: Build and Deploy

on:
  workflow_dispatch:
    inputs:
      repo_url:
        description: '代码仓库地址 (GitHub或Gitee)'
        required: true
      branch:
        description: '分支名称'
        default: 'main'
        required: true
      image_name:
        description: '镜像名称'
        required: true
      image_tag:
        description: '镜像标签'
        default: 'latest'
        required: true
      registry:
        description: '镜像仓库地址'
        default: 'docker.io'
        required: true
      callback_url:
        description: '回调通知URL'
        required: false
      docker_auth:
        description: 'Docker认证(格式:username:password)'
        required: true
      ai_options:
        description: 'AI优化选项(size|security|speed)'
        default: 'size'
        required: false
      repo_token:
        description: '仓库访问令牌(私有仓库需要)'
        required: false

# 权限设置 - 包含AI访问
permissions:
  contents: write
  id-token: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: 检查输入参数
        run: |
          echo "代码仓库: ${{ github.event.inputs.repo_url }}"
          echo "分支: ${{ github.event.inputs.branch }}"
          echo "镜像名称: ${{ github.event.inputs.image_name }}"
          echo "镜像标签: ${{ github.event.inputs.image_tag }}"
          echo "镜像仓库: ${{ github.event.inputs.registry }}"

      - name: 克隆源代码
        run: |
          repo_url="${{ github.event.inputs.repo_url }}"
          repo_token="${{ github.event.inputs.repo_token }}"
          branch="${{ github.event.inputs.branch }}"
          
          # 直接使用用户提供的分支
          echo "使用用户指定分支: $branch"
          
          # 处理私有仓库的身份验证
          if [ -n "$repo_token" ]; then
            # GitHub 仓库
            if [[ $repo_url == *github.com* ]]; then
              auth_repo_url=$(echo $repo_url | sed "s/https:\/\//https:\/\/$repo_token@/")
              git clone --depth 1 -b $branch $auth_repo_url src || git clone --depth 1 $auth_repo_url src
            
            # Gitee 仓库
            elif [[ $repo_url == *gitee.com* ]]; then
              auth_repo_url=$(echo $repo_url | sed "s/https:\/\//https:\/\/$repo_token@/")
              git clone --depth 1 -b $branch $auth_repo_url src || git clone --depth 1 $auth_repo_url src
            
            else
              echo "不支持的仓库类型，但尝试使用令牌进行克隆"
              auth_repo_url=$(echo $repo_url | sed "s/https:\/\//https:\/\/$repo_token@/")
              git clone --depth 1 -b $branch $auth_repo_url src || git clone --depth 1 $auth_repo_url src
            fi
          else
            # 公开仓库，无需令牌
            git clone --depth 1 -b $branch $repo_url src || git clone --depth 1 $repo_url src
          fi
          
          if [ ! -d "src" ]; then
            echo "克隆失败，请检查仓库地址和分支名称是否正确"
            exit 1
          fi
        shell: bash

      # 登录Docker仓库
      - name: 登录镜像仓库
        run: |
          # 分割Docker认证字符串
          DOCKER_AUTH="${{ github.event.inputs.docker_auth }}"
          DOCKER_USERNAME=$(echo $DOCKER_AUTH | cut -d':' -f1)
          DOCKER_PASSWORD=$(echo $DOCKER_AUTH | cut -d':' -f2-)
          
          # 使用Docker登录命令
          echo $DOCKER_PASSWORD | docker login ${{ github.event.inputs.registry }} -u $DOCKER_USERNAME --password-stdin
        shell: bash

      # 设置GitHub CLI与Copilot支持
      - name: 设置GitHub CLI与Copilot支持
        run: |
          # 安装GitHub CLI扩展
          gh extension install github/gh-copilot || {
            echo "GitHub Copilot扩展安装失败，AI不可用"
            exit 1
          }
          echo "已安装GitHub Copilot CLI扩展"
          
          # 验证扩展是否正确安装
          if gh extension list | grep -q copilot; then
            echo "GitHub Copilot CLI扩展安装成功"
          else
            echo "GitHub Copilot CLI扩展不可用，AI功能无法使用"
            exit 1
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # 项目预检测
      - name: 项目预检测
        id: project-detection
        run: |
          cd src
          
          # 检查是否存在自定义Dockerfile
          if [ -f "Dockerfile" ]; then
            echo "检测到自定义Dockerfile，将使用项目已有的Dockerfile"
            echo "use_existing_dockerfile=true" >> $GITHUB_OUTPUT
          else
            echo "未检测到Dockerfile，将使用AI生成"
            echo "use_existing_dockerfile=false" >> $GITHUB_OUTPUT
            
            # 收集项目信息以辅助AI分析
            echo "项目结构:" >> project_info.txt
            find . -type f -name "*.json" -o -name "*.py" -o -name "*.js" -o -name "*.ts" -o -name "*.java" -o -name "*.xml" -o -name "*.go" | sort >> project_info.txt
            
            # 检测主要技术栈
            if [ -f "package.json" ]; then
              echo "检测到Node.js项目" >> project_info.txt
              echo "package.json内容:" >> project_info.txt
              cat package.json >> project_info.txt
            elif [ -f "requirements.txt" ]; then
              echo "检测到Python项目" >> project_info.txt
              echo "requirements.txt内容:" >> project_info.txt
              cat requirements.txt >> project_info.txt
            elif [ -f "pom.xml" ]; then
              echo "检测到Java项目" >> project_info.txt
              echo "pom.xml关键依赖:" >> project_info.txt
              grep -A 5 -B 5 "<dependency>" pom.xml >> project_info.txt
            elif [ -f "go.mod" ]; then
              echo "检测到Go项目" >> project_info.txt
              echo "go.mod内容:" >> project_info.txt
              cat go.mod >> project_info.txt
            fi
          fi
        shell: bash

      # 使用AI生成Dockerfile
      - name: 使用讯飞星火Spark Lite生成Dockerfile
        if: steps.project-detection.outputs.use_existing_dockerfile == 'false'
        id: generate-dockerfile
        run: |
          cd src
          echo "开始使用讯飞星火AI分析项目并生成Dockerfile..."
          
          # 准备更详细的项目分析
          echo "正在进行深度项目分析..."
          
          # 检查入口文件
          if [ -f "package.json" ]; then
            echo "分析Node.js入口点和依赖项..."
            # 使用更健壮的方式提取package.json信息
            if [ -x "$(command -v jq)" ]; then
              # 如果有jq命令，使用jq解析json
              MAIN_FILE=$(jq -r '.main // ""' package.json 2>/dev/null || echo "")
              START_SCRIPT=$(jq -r '.scripts.start // ""' package.json 2>/dev/null || echo "")
              BUILD_SCRIPT=$(jq -r '.scripts.build // ""' package.json 2>/dev/null || echo "")
            else
              # 备用方案：使用更简单的grep模式且添加错误处理
              MAIN_FILE=$(grep -o '"main"\s*:\s*"[^"]*"' package.json 2>/dev/null | sed 's/.*"main"\s*:\s*"\([^"]*\)".*/\1/' || echo "")
              START_SCRIPT=$(grep -o '"start"\s*:\s*"[^"]*"' package.json 2>/dev/null | sed 's/.*"start"\s*:\s*"\([^"]*\)".*/\1/' || echo "")
              BUILD_SCRIPT=$(grep -o '"build"\s*:\s*"[^"]*"' package.json 2>/dev/null | sed 's/.*"build"\s*:\s*"\([^"]*\)".*/\1/' || echo "")
            fi
            
            echo "主入口文件: ${MAIN_FILE:-未指定}" >> ../project_analysis.txt
            echo "启动脚本: ${START_SCRIPT:-未指定}" >> ../project_analysis.txt
            echo "构建脚本: ${BUILD_SCRIPT:-未指定}" >> ../project_analysis.txt
          elif [ -f "requirements.txt" ]; then
            echo "分析Python应用结构..."
            # 查找可能的Python入口点
            FLASK_APP=$(grep -l "Flask(" $(find . -name "*.py" 2>/dev/null) 2>/dev/null | head -1 || echo "")
            DJANGO_APP=$(find . -name "manage.py" 2>/dev/null | head -1 || echo "")
            if [ -n "$FLASK_APP" ]; then
              echo "检测到Flask应用，入口点: $FLASK_APP" >> ../project_analysis.txt
            elif [ -n "$DJANGO_APP" ]; then
              echo "检测到Django应用，入口点: $DJANGO_APP" >> ../project_analysis.txt
            fi
          fi
          
          # 准备提示信息
          PROMPT="分析以下源代码仓库，创建一个生产级别的Dockerfile。要求:"
          
          # 根据用户选择的优化选项调整提示
          AI_OPTION="${{ github.event.inputs.ai_options }}"
          if [ "$AI_OPTION" == "size" ] || [ -z "$AI_OPTION" ]; then
            PROMPT="$PROMPT
            1. 优先考虑减小镜像大小，使用轻量级基础镜像
            2. 使用多阶段构建以优化最终镜像体积
            3. 移除构建依赖和中间产物
            4. 最小化层数和大小"
          elif [ "$AI_OPTION" == "security" ]; then
            PROMPT="$PROMPT
            1. 优先考虑安全性，使用官方安全基础镜像
            2. 添加用户权限控制，避免使用root用户
            3. 最小化攻击面，仅包含必要组件
            4. 实施安全扫描和最佳实践"
          elif [ "$AI_OPTION" == "speed" ]; then
            PROMPT="$PROMPT
            1. 优先考虑应用启动和运行速度
            2. 优化缓存和层结构提高构建速度
            3. 预安装关键依赖
            4. 配置应用优化参数"
          fi
          
          PROMPT="$PROMPT
          
          已收集的项目信息:
          $(cat ../project_info.txt 2>/dev/null || echo '未找到项目信息')
          $(cat ../project_analysis.txt 2>/dev/null || echo '')
          
          请生成完整的Dockerfile，不要包含任何注释或解释。"
          
          # 将PROMPT保存为文件
          echo "$PROMPT" > ../prompt.txt
          
          # 配置讯飞星火API参数
          SPARK_API_PASSWORD="${{ secrets.SPARK_API_PASSWORD }}"
          
          # 如果secrets未设置，使用用户提供的默认值
          if [ -z "$SPARK_API_PASSWORD" ]; then
            # 使用用户提供的密钥
            SPARK_API_PASSWORD="ksdxvpoAEoUgBgqShIIb"
          fi
          
          # 生成请求URL
          AUTH_URL="https://spark-api-open.xf-yun.com/v1/chat/completions"
          
          # 读取PROMPT内容并转义为JSON字符串
          PROMPT_CONTENT=$(cat ../prompt.txt | sed 's/"/\\"/g' | tr '\n' ' ')
          
          # 构建请求体JSON
          echo '{
            "model": "lite",
            "messages": [
              {
                "role": "user",
                "content": "'$PROMPT_CONTENT'"
              }
            ],
            "temperature": 0.5,
            "max_tokens": 4096
          }' > ../spark_request.json
          
          # 执行HTTP请求
          echo "调用讯飞星火API生成Dockerfile..."
          curl -s -X POST "$AUTH_URL" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $SPARK_API_PASSWORD" \
            -d @../spark_request.json > ../ai_response.json
          
          # 检查API调用是否成功
          if [ $? -ne 0 ]; then
            echo "讯飞星火API调用失败"
            exit 1
          fi
          
          # 显示API响应状态
          CODE=$(jq -r '.code // 1' ../ai_response.json 2>/dev/null || echo "1")
          if [ "$CODE" != "0" ]; then
            echo "讯飞星火API返回错误，错误代码: $CODE"
            echo "错误信息: $(jq -r '.message // "未知错误"' ../ai_response.json 2>/dev/null || echo "未知错误")"
            exit 1
          fi
          
          # 从响应中提取Dockerfile内容
          if [ -x "$(command -v jq)" ]; then
            # 使用jq解析json
            jq -r '.choices[0].message.content' ../ai_response.json > Dockerfile
          else
            # 备用方案：使用grep提取
            grep -o '"content":"[^"]*"' ../ai_response.json | head -1 | sed 's/"content":"//;s/"$//' > Dockerfile
          fi
          
          # 清理Dockerfile (移除可能的markdown代码块标记)
          sed -i 's/```dockerfile//g' Dockerfile
          sed -i 's/```//g' Dockerfile
          
          # 检查生成结果
          if [ ! -s Dockerfile ]; then
            echo "AI生成Dockerfile失败，无有效输出"
            echo "API返回内容:" 
            cat ../ai_response.json
            exit 1
          else
            echo "AI已成功生成Dockerfile:"
            cat Dockerfile
          fi
        shell: bash

      # 验证AI生成的Dockerfile
      - name: 验证Dockerfile
        if: steps.project-detection.outputs.use_existing_dockerfile == 'false'
        run: |
          cd src
          echo "验证AI生成的Dockerfile..."
          
          # 检查Dockerfile基本结构
          if ! grep -q "FROM" Dockerfile; then
            echo "警告: Dockerfile缺少FROM指令，添加默认基础镜像..."
            echo "FROM node:16-alpine" > Dockerfile.new
            cat Dockerfile >> Dockerfile.new
            mv Dockerfile.new Dockerfile
          fi
          
          # 确保包含WORKDIR
          if ! grep -q "WORKDIR" Dockerfile; then
            echo "警告: Dockerfile缺少WORKDIR指令，添加默认工作目录..."
            sed -i '/FROM/a WORKDIR /app' Dockerfile
          fi
          
          # 确保有COPY指令
          if ! grep -q "COPY" Dockerfile; then
            echo "警告: Dockerfile缺少COPY指令，添加默认文件复制..."
            echo "COPY . ." >> Dockerfile
          fi
          
          # 确保有CMD或ENTRYPOINT
          if ! grep -q "CMD" Dockerfile && ! grep -q "ENTRYPOINT" Dockerfile; then
            echo "警告: Dockerfile缺少CMD或ENTRYPOINT指令，添加默认命令..."
            echo "CMD [\"sh\", \"-c\", \"if [ -f package.json ]; then npm start; elif [ -f requirements.txt ]; then python app.py; else echo 'Unable to determine start command' && exit 1; fi\"]" >> Dockerfile
          fi
          
          echo "Dockerfile验证完成，最终内容:"
          cat Dockerfile
        shell: bash

      # 使用AI生成的Dockerfile构建镜像
      - name: 构建AI生成的Dockerfile
        if: steps.project-detection.outputs.use_existing_dockerfile == 'false'
        uses: docker/build-push-action@v4
        with:
          context: ./src
          push: true
          tags: ${{ github.event.inputs.registry }}/${{ github.event.inputs.image_name }}:${{ github.event.inputs.image_tag }}
          # 简化的缓存配置
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # 使用项目自带Dockerfile构建
      - name: 使用项目自带Dockerfile构建
        if: steps.project-detection.outputs.use_existing_dockerfile == 'true'
        uses: docker/build-push-action@v4
        with:
          context: ./src
          push: true
          tags: ${{ github.event.inputs.registry }}/${{ github.event.inputs.image_name }}:${{ github.event.inputs.image_tag }}
          # 简化的缓存配置
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # 构建完成后通知
      - name: 通知构建完成
        if: ${{ success() && github.event.inputs.callback_url != '' }}
        run: |
          # 保存Dockerfile的副本，用于通知
          if [ -f "src/Dockerfile" ]; then
            cp src/Dockerfile ./dockerfile_used.txt
          fi
          
          # 确定是用AI生成还是使用现有的Dockerfile
          if [ "${{ steps.project-detection.outputs.use_existing_dockerfile }}" == "true" ]; then
            DOCKERFILE_SOURCE="使用项目自带的Dockerfile"
          else
            DOCKERFILE_SOURCE="由AI自动生成Dockerfile"
          fi
          
          # 发送包含更多信息的通知
          curl -X POST ${{ github.event.inputs.callback_url }} \
            -H "Content-Type: application/json" \
            -d '{
              "status": "success",
              "image": "${{ github.event.inputs.registry }}/${{ github.event.inputs.image_name }}:${{ github.event.inputs.image_tag }}",
              "repo_url": "${{ github.event.inputs.repo_url }}",
              "branch": "${{ github.event.inputs.branch }}",
              "build_id": "${{ github.run_id }}",
              "dockerfile_source": "'"$DOCKERFILE_SOURCE"'",
              "ai_option": "${{ github.event.inputs.ai_options }}"
            }'
        shell: bash

      # 构建失败后通知
      - name: 通知构建失败
        if: ${{ failure() && github.event.inputs.callback_url != '' }}
        run: |
          # 如果生成了Dockerfile但构建失败，提供Dockerfile供分析
          DOCKERFILE_CONTENT=""
          if [ -f "src/Dockerfile" ]; then
            DOCKERFILE_CONTENT=$(cat src/Dockerfile | base64 -w 0)
          fi
          
          curl -X POST ${{ github.event.inputs.callback_url }} \
            -H "Content-Type: application/json" \
            -d '{
              "status": "failed",
              "repo_url": "${{ github.event.inputs.repo_url }}",
              "branch": "${{ github.event.inputs.branch }}",
              "build_id": "${{ github.run_id }}",
              "dockerfile_content_base64": "'"$DOCKERFILE_CONTENT"'"
            }'
        shell: bash 