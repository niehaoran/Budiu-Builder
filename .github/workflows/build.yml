name: Build and Deploy

on:
  workflow_dispatch:
    inputs:
      repo_url:
        description: '代码仓库地址 (GitHub或Gitee)'
        required: true
      branch:
        description: '分支名称'
        default: 'main'
        required: true
      build_context:
        description: '构建上下文和Dockerfile (格式: 上下文路径:Dockerfile路径，默认为.:Dockerfile)'
        default: '.:Dockerfile'
        required: false
      build_args:
        description: '构建参数 (格式: KEY1=VALUE1,KEY2=VALUE2)'
        default: ''
        required: false
      image_name:
        description: '镜像名称'
        required: true
      image_tag:
        description: '镜像标签'
        default: 'latest'
        required: true
      registry:
        description: '镜像仓库地址'
        default: 'docker.io'
        required: true
      docker_auth:
        description: 'Docker仓库认证 (格式: 用户名:密码)'
        required: true
      advanced_options:
        description: '高级选项 (格式: platforms=linux/amd64|callback_url=http://...|repo_token=xxx)'
        default: 'platforms=linux/amd64'
        required: false

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: 解析参数
        id: parse_params
        run: |
          # 解析构建上下文和Dockerfile路径
          build_context="${{ github.event.inputs.build_context }}"
          IFS=':' read -r context_dir dockerfile_path <<< "$build_context"
          # 默认值处理
          context_dir=${context_dir:-'.'}
          dockerfile_path=${dockerfile_path:-'Dockerfile'}
          
          echo "context_dir=$context_dir" >> $GITHUB_OUTPUT
          echo "dockerfile_path=$dockerfile_path" >> $GITHUB_OUTPUT
          
          # 解析Docker认证信息
          docker_auth="${{ github.event.inputs.docker_auth }}"
          IFS=':' read -r docker_username docker_password <<< "$docker_auth"
          echo "docker_username=$docker_username" >> $GITHUB_OUTPUT
          # 密码不输出到日志
          
          # 解析高级选项
          advanced="${{ github.event.inputs.advanced_options }}"
          # 提取平台信息
          if [[ $advanced == *"platforms="* ]]; then
            platforms=$(echo "$advanced" | grep -oP 'platforms=\K[^|]*')
          else
            platforms="linux/amd64"
          fi
          echo "platforms=$platforms" >> $GITHUB_OUTPUT
          
          # 提取回调URL
          if [[ $advanced == *"callback_url="* ]]; then
            callback_url=$(echo "$advanced" | grep -oP 'callback_url=\K[^|]*')
            echo "callback_url=$callback_url" >> $GITHUB_OUTPUT
            echo "has_callback=true" >> $GITHUB_OUTPUT
          else
            echo "has_callback=false" >> $GITHUB_OUTPUT
          fi
          
          # 提取仓库令牌
          if [[ $advanced == *"repo_token="* ]]; then
            repo_token=$(echo "$advanced" | grep -oP 'repo_token=\K[^|]*')
            echo "repo_token=$repo_token" >> $GITHUB_OUTPUT
            echo "has_repo_token=true" >> $GITHUB_OUTPUT
          else
            echo "has_repo_token=false" >> $GITHUB_OUTPUT
          fi
        shell: bash

      - name: 检查输入参数
        run: |
          echo "代码仓库: ${{ github.event.inputs.repo_url }}"
          echo "分支: ${{ github.event.inputs.branch }}"
          echo "构建上下文: ${{ steps.parse_params.outputs.context_dir }}"
          echo "Dockerfile路径: ${{ steps.parse_params.outputs.dockerfile_path }}"
          echo "镜像名称: ${{ github.event.inputs.image_name }}"
          echo "镜像标签: ${{ github.event.inputs.image_tag }}"
          echo "镜像仓库: ${{ github.event.inputs.registry }}"
          echo "构建平台: ${{ steps.parse_params.outputs.platforms }}"
        shell: bash

      - name: 克隆源代码
        run: |
          repo_url="${{ github.event.inputs.repo_url }}"
          branch="${{ github.event.inputs.branch }}"
          
          # 获取仓库令牌
          has_repo_token="${{ steps.parse_params.outputs.has_repo_token }}"
          repo_token="${{ steps.parse_params.outputs.repo_token }}"
          
          # 尝试自动检测默认分支
          if [ "$branch" = "main" ] || [ "$branch" = "master" ]; then
            echo "尝试自动检测默认分支..."
            
            if [[ $repo_url == *github.com* ]]; then
              repo_path=$(echo $repo_url | sed -E 's/https:\/\/github.com\/|git@github.com://;s/.git$//')
              default_branch=$(curl -s https://api.github.com/repos/$repo_path | grep -o '"default_branch": "[^"]*' | cut -d'"' -f4)
            fi
            
            if [ -n "$default_branch" ]; then
              echo "自动检测到默认分支: $default_branch"
              branch=$default_branch
            fi
          fi
          
          echo "最终使用分支: $branch"
          
          # 处理私有仓库的身份验证
          if [ "$has_repo_token" == "true" ]; then
            # GitHub 仓库
            if [[ $repo_url == *github.com* ]]; then
              auth_repo_url=$(echo $repo_url | sed "s/https:\/\//https:\/\/$repo_token@/")
              git clone --depth 1 -b $branch $auth_repo_url src || git clone --depth 1 $auth_repo_url src
            
            # Gitee 仓库
            elif [[ $repo_url == *gitee.com* ]]; then
              auth_repo_url=$(echo $repo_url | sed "s/https:\/\//https:\/\/$repo_token@/")
              git clone --depth 1 -b $branch $auth_repo_url src || git clone --depth 1 $auth_repo_url src
            
            else
              echo "不支持的仓库类型，但尝试使用令牌进行克隆"
              auth_repo_url=$(echo $repo_url | sed "s/https:\/\//https:\/\/$repo_token@/")
              git clone --depth 1 -b $branch $auth_repo_url src || git clone --depth 1 $auth_repo_url src
            fi
          else
            # 公开仓库，无需令牌
            git clone --depth 1 -b $branch $repo_url src || git clone --depth 1 $repo_url src
          fi
          
          if [ ! -d "src" ]; then
            echo "克隆失败，请检查仓库地址和分支名称是否正确"
            exit 1
          fi
        shell: bash

      - name: 检查是否存在Dockerfile
        id: check_dockerfile
        run: |
          # 获取Dockerfile路径
          context_dir="${{ steps.parse_params.outputs.context_dir }}"
          dockerfile_path="${{ steps.parse_params.outputs.dockerfile_path }}"
          full_dockerfile_path="src/$context_dir/$dockerfile_path"
          
          # 兼容处理：如果dockerfile_path已经包含context_dir，不要重复添加
          if [[ "$dockerfile_path" == "$context_dir"* ]]; then
            full_dockerfile_path="src/$dockerfile_path"
          fi
          
          echo "检查Dockerfile路径: $full_dockerfile_path"
          
          if [ -f "$full_dockerfile_path" ]; then
            echo "Dockerfile找到: $full_dockerfile_path"
            echo "dockerfile_exists=true" >> $GITHUB_OUTPUT
            echo "dockerfile_path=$full_dockerfile_path" >> $GITHUB_OUTPUT
          else
            echo "错误: Dockerfile未找到。请确保正确设置Dockerfile路径。"
            echo "dockerfile_exists=false" >> $GITHUB_OUTPUT
            exit 1
          fi
        shell: bash

      # 设置Docker Buildx (支持多平台构建)
      - name: 设置Docker Buildx
        uses: docker/setup-buildx-action@v2
        with:
          platforms: ${{ steps.parse_params.outputs.platforms }}
          buildkitd-flags: --debug

      # 登录Docker仓库
      - name: 登录镜像仓库
        uses: docker/login-action@v2
        with:
          registry: ${{ github.event.inputs.registry }}
          username: ${{ steps.parse_params.outputs.docker_username }}
          password: ${{ steps.parse_params.outputs.docker_password }}
      
      # 处理构建参数
      - name: 准备构建参数
        id: build_params
        run: |
          # 解析构建参数
          build_args="${{ github.event.inputs.build_args }}"
          context_dir="${{ steps.parse_params.outputs.context_dir }}"
          
          # 构建上下文路径
          full_context_path="src/$context_dir"
          echo "context_path=$full_context_path" >> $GITHUB_OUTPUT
          
          # 转换构建参数为Docker Buildx可用格式
          if [ -n "$build_args" ]; then
            echo "构建参数: $build_args"
            # 首先将逗号分隔转为换行符
            build_args_list=$(echo $build_args | tr ',' '\n')
            # 然后为每个参数构建--build-arg选项
            build_args_formatted=""
            while IFS= read -r arg; do
              if [ -n "$arg" ]; then
                build_args_formatted="$build_args_formatted --build-arg $arg"
              fi
            done <<< "$build_args_list"
            echo "构建参数格式化完成: $build_args_formatted"
            echo "build_args=$build_args_formatted" >> $GITHUB_OUTPUT
          else
            echo "没有提供构建参数"
            echo "build_args=" >> $GITHUB_OUTPUT
          fi
        shell: bash

      # 使用Docker Buildx构建并推送镜像
      - name: 构建并推送Docker镜像
        env:
          CONTEXT_PATH: ${{ steps.build_params.outputs.context_path }}
          DOCKERFILE_PATH: ${{ steps.check_dockerfile.outputs.dockerfile_path }}
          BUILD_ARGS: ${{ steps.build_params.outputs.build_args }}
          PLATFORMS: ${{ steps.parse_params.outputs.platforms }}
        run: |
          # 显示构建信息
          echo "构建上下文: $CONTEXT_PATH"
          echo "Dockerfile路径: $DOCKERFILE_PATH"
          echo "构建参数: $BUILD_ARGS"
          echo "构建平台: $PLATFORMS"
          
          # 执行构建命令
          docker buildx build \
            --platform $PLATFORMS \
            -t ${{ github.event.inputs.registry }}/${{ github.event.inputs.image_name }}:${{ github.event.inputs.image_tag }} \
            -f $DOCKERFILE_PATH \
            $BUILD_ARGS \
            --push \
            --cache-from type=gha \
            --cache-to type=gha,mode=max \
            $CONTEXT_PATH
        shell: bash

      # 构建完成后通知
      - name: 通知构建完成
        if: ${{ success() && steps.parse_params.outputs.has_callback == 'true' }}
        run: |
          callback_url="${{ steps.parse_params.outputs.callback_url }}"
          
          curl -X POST $callback_url \
            -H "Content-Type: application/json" \
            -d '{
              "status": "success",
              "image": "${{ github.event.inputs.registry }}/${{ github.event.inputs.image_name }}:${{ github.event.inputs.image_tag }}",
              "repo_url": "${{ github.event.inputs.repo_url }}",
              "branch": "${{ github.event.inputs.branch }}",
              "build_id": "${{ github.run_id }}"
            }'
        shell: bash

      # 构建失败后通知
      - name: 通知构建失败
        if: ${{ failure() && steps.parse_params.outputs.has_callback == 'true' }}
        run: |
          callback_url="${{ steps.parse_params.outputs.callback_url }}"
          
          curl -X POST $callback_url \
            -H "Content-Type: application/json" \
            -d '{
              "status": "failed",
              "repo_url": "${{ github.event.inputs.repo_url }}",
              "branch": "${{ github.event.inputs.branch }}",
              "build_id": "${{ github.run_id }}"
            }'
        shell: bash 