name: Budiu 智能构建部署

on:
  workflow_dispatch:
    inputs:
      repo_url:
        description: '代码仓库地址 (GitHub或Gitee)'
        required: true
      branch:
        description: '分支名称'
        default: 'main'
        required: true
      image_name:
        description: '镜像名称'
        required: true
      image_tag:
        description: '镜像标签'
        default: 'latest'
        required: true
      registry:
        description: '镜像仓库地址'
        default: 'docker.io'
        required: true
      callback_url:
        description: '回调通知URL'
        required: false
      docker_auth:
        description: 'Docker认证(格式:username:password)'
        required: true
      ai_options:
        description: 'AI优化选项(size|security|speed)'
        default: 'size'
        required: false
      repo_token:
        description: '仓库访问令牌(私有仓库需要)'
        required: false

# 权限设置 - 包含AI访问
permissions:
  contents: write
  id-token: write

jobs:
  build-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: 配置初始化
        run: echo "开始Budiu智能构建部署流程..."

      - name: 检查输入参数
        run: |
          echo "代码仓库: ${{ github.event.inputs.repo_url }}"
          echo "分支: ${{ github.event.inputs.branch }}"
          echo "镜像名称: ${{ github.event.inputs.image_name }}"
          echo "镜像标签: ${{ github.event.inputs.image_tag }}"
          echo "镜像仓库: ${{ github.event.inputs.registry }}"

      - name: 克隆源代码
        run: |
          repo_url="${{ github.event.inputs.repo_url }}"
          repo_token="${{ github.event.inputs.repo_token }}"
          branch="${{ github.event.inputs.branch }}"
          
          if [ -n "$repo_token" ]; then
            auth_repo_url=$(echo $repo_url | sed "s/https:\/\//https:\/\/$repo_token@/")
            git clone --depth 1 -b $branch $auth_repo_url src || git clone --depth 1 $auth_repo_url src
          else
            git clone --depth 1 -b $branch $repo_url src || git clone --depth 1 $repo_url src
          fi
          
          if [ ! -d "src" ]; then
            echo "克隆失败，请检查仓库地址和分支名称"
            exit 1
          fi

      - name: 登录镜像仓库
        run: |
          DOCKER_AUTH="${{ github.event.inputs.docker_auth }}"
          DOCKER_USERNAME=$(echo $DOCKER_AUTH | cut -d':' -f1)
          DOCKER_PASSWORD=$(echo $DOCKER_AUTH | cut -d':' -f2-)
          
          echo $DOCKER_PASSWORD | docker login ${{ github.event.inputs.registry }} -u $DOCKER_USERNAME --password-stdin

      - name: 设置Docker Buildx
        uses: docker/setup-buildx-action@v2
        with:
          install: true

      # 项目预检测
      - name: 项目预检测
        id: project-detection
        run: |
          cd src
          
          # 检查是否存在自定义Dockerfile
          if [ -f "Dockerfile" ]; then
            echo "检测到自定义Dockerfile，将使用项目已有的Dockerfile"
            echo "use_existing_dockerfile=true" >> $GITHUB_OUTPUT
          else
            echo "未检测到Dockerfile，将使用AI生成"
            echo "use_existing_dockerfile=false" >> $GITHUB_OUTPUT
            
            # 收集项目信息
            echo "项目结构:" > ../project_info.txt
            find . -type f -not -path "*/\.*" | sort >> ../project_info.txt
            
            # 读取根目录文件
            echo "根目录文件列表:" >> ../project_info.txt
            ls -la >> ../project_info.txt
            
            # 读取README文件
            if [ -f "README.md" ]; then
              echo "README.md内容:" >> ../project_info.txt
              cat README.md >> ../project_info.txt
            fi
          fi
        shell: bash

      # 深度项目分析
      - name: 深度项目分析
        if: steps.project-detection.outputs.use_existing_dockerfile == 'false'
        run: |
          cd src
          echo "进行深度项目分析..." > ../project_analysis.txt
          
          # 分析项目目录结构
          find . -type f -not -path "*/\.*" -not -path "*/node_modules/*" | sort >> ../project_analysis.txt
          
          # 检测主要技术栈
          if [ -f "package.json" ]; then
            echo "检测到Node.js项目" >> ../project_analysis.txt
            echo "package.json内容:" >> ../project_analysis.txt
            cat package.json >> ../project_analysis.txt
          elif [ -f "requirements.txt" ]; then
            echo "检测到Python项目" >> ../project_analysis.txt
            cat requirements.txt >> ../project_analysis.txt
          elif [ -f "pom.xml" ]; then
            echo "检测到Java项目" >> ../project_analysis.txt
            cat pom.xml >> ../project_analysis.txt
          fi
        shell: bash

      # 准备AI提示
      - name: 准备AI提示
        if: steps.project-detection.outputs.use_existing_dockerfile == 'false'
        id: prepare-prompt
        run: |
          # 基础提示
          echo "准备AI提示内容..."
          echo "请基于项目分析结果，创建高质量Dockerfile，考虑：" > ../prompt.txt
          echo "1. 选择合适的基础镜像(优先alpine版本)" >> ../prompt.txt
          echo "2. 使用多阶段构建分离构建环境和运行环境" >> ../prompt.txt
          echo "3. 仅复制必要文件，优化层顺序，合并RUN命令" >> ../prompt.txt
          echo "4. 清理不必要的缓存和临时文件" >> ../prompt.txt
          echo "5. 选择合适的端口和启动命令" >> ../prompt.txt
          
          # 根据优化选项调整提示
          AI_OPTION="${{ github.event.inputs.ai_options }}"
          if [ "$AI_OPTION" == "size" ] || [ -z "$AI_OPTION" ]; then
            echo "优化目标：最小化镜像体积" >> ../prompt.txt
          elif [ "$AI_OPTION" == "security" ]; then
            echo "优化目标：提高安全性" >> ../prompt.txt
          elif [ "$AI_OPTION" == "speed" ]; then
            echo "优化目标：提高构建和运行速度" >> ../prompt.txt
          fi
          
          # 添加收集的项目信息
          echo "项目信息:" >> ../prompt.txt
          cat ../project_info.txt >> ../prompt.txt
          cat ../project_analysis.txt >> ../prompt.txt
          
      # 使用讯飞星火AI生成Dockerfile
      - name: 使用讯飞星火AI生成Dockerfile
        if: steps.project-detection.outputs.use_existing_dockerfile == 'false'
        id: generate-dockerfile
        run: |
          cd src
          echo "使用讯飞星火AI分析项目并生成Dockerfile..."
          
          # 获取提示内容
          PROMPT=$(cat ../prompt.txt)
          
          # API认证和请求参数
          SPARK_API_PASSWORD="${{ secrets.SPARK_API_PASSWORD }}"
          AUTH_URL="https://spark-api-open.xf-yun.com/v1/chat/completions"
          
          # 确保密钥存在
          if [ -z "$SPARK_API_PASSWORD" ]; then
            echo "错误: 未设置SPARK_API_PASSWORD密钥"
            exit 1
          fi

      # 验证AI生成的Dockerfile
      - name: 验证Dockerfile
        if: steps.project-detection.outputs.use_existing_dockerfile == 'false'
        run: |
          cd src
          echo "验证AI生成的Dockerfile..."
          
          # 检查基础镜像是否是alpine版本
          if ! grep -q "alpine" Dockerfile; then
            echo "警告: 基础镜像不是alpine版本，替换为轻量级alpine镜像..."
            # 识别当前使用的node版本
            NODE_VER=$(grep -o "node:[0-9]*" Dockerfile | head -1 | cut -d':' -f2)
            NODE_VER=${NODE_VER:-14}
            # 备份原始Dockerfile
            cp Dockerfile Dockerfile.original
            # 替换基础镜像
            sed -i "s|FROM node:$NODE_VER|FROM node:$NODE_VER-alpine|g" Dockerfile
            # 如果没有多阶段构建，尝试添加
            if [ $(grep -c "FROM" Dockerfile) -eq 1 ]; then
              echo "警告: 未使用多阶段构建，添加构建和运行阶段..."
              NODE_VERSION=$NODE_VER
              
              echo "# 构建阶段" > Dockerfile.new
              echo "FROM node:${NODE_VERSION}-alpine AS builder" >> Dockerfile.new
              echo "WORKDIR /app" >> Dockerfile.new
              echo "COPY package*.json ./" >> Dockerfile.new
              echo "RUN npm ci --only=production || npm install --production" >> Dockerfile.new
              echo "COPY . ." >> Dockerfile.new
              echo "" >> Dockerfile.new
              echo "# 运行阶段" >> Dockerfile.new
              echo "FROM node:${NODE_VERSION}-alpine" >> Dockerfile.new
              echo "WORKDIR /app" >> Dockerfile.new
              echo "COPY --from=builder /app/package*.json ./" >> Dockerfile.new
              echo "COPY --from=builder /app/node_modules ./node_modules" >> Dockerfile.new
              echo "# 只复制需要的文件，避免复制node_modules等" >> Dockerfile.new
              echo "COPY --from=builder /app/src ./src" >> Dockerfile.new
              echo "COPY --from=builder /app/public ./public 2>/dev/null || true" >> Dockerfile.new
              echo "COPY --from=builder /app/*.js ./ 2>/dev/null || true" >> Dockerfile.new
              echo "COPY --from=builder /app/*.json ./ 2>/dev/null || true" >> Dockerfile.new
              echo "" >> Dockerfile.new
              echo "# 设置运行命令" >> Dockerfile.new
              echo "CMD [\"npm\", \"start\"]" >> Dockerfile.new

              mv Dockerfile.new Dockerfile
            else
              # 如果已有多阶段构建，检查是否有循环依赖
              echo "检查多阶段构建是否有循环依赖..."
              # 查找COPY --from=N指令中的N是否定义清晰
              # 创建临时文件进行修复
              cp Dockerfile Dockerfile.tmp
              
              # 获取阶段数量
              STAGE_COUNT=$(grep -c "^FROM" Dockerfile)
              
              # 如果没有明确的阶段命名，给第一个阶段添加名称
              if ! grep -q "FROM .* AS " Dockerfile; then
                # 给第一个FROM添加AS builder
                sed -i '0,/^FROM/s/^FROM \(.*\)$/FROM \1 AS builder/' Dockerfile.tmp
                # 将所有--from=0替换为--from=builder
                sed -i 's/COPY --from=0/COPY --from=builder/g' Dockerfile.tmp
              fi
              
              # 应用修改
              mv Dockerfile.tmp Dockerfile
            fi
          fi
          
          # 检查Dockerfile基本结构
          if ! grep -q "FROM" Dockerfile; then
            echo "警告: Dockerfile缺少FROM指令，添加默认基础镜像..."
            echo "FROM node:14-alpine" > Dockerfile.new
            cat Dockerfile >> Dockerfile.new
            mv Dockerfile.new Dockerfile
          fi
          
          # 确保包含WORKDIR
          if ! grep -q "WORKDIR" Dockerfile; then
            echo "警告: Dockerfile缺少WORKDIR指令，添加默认工作目录..."
            sed -i '/FROM/a WORKDIR /app' Dockerfile
          fi
          
          # 确保有COPY指令
          if ! grep -q "COPY" Dockerfile; then
            echo "警告: Dockerfile缺少COPY指令，添加默认文件复制..."
            echo "COPY . ." >> Dockerfile
          fi
          
          # 确保有CMD或ENTRYPOINT
          if ! grep -q "CMD" Dockerfile && ! grep -q "ENTRYPOINT" Dockerfile; then
            echo "警告: Dockerfile缺少CMD或ENTRYPOINT指令，添加默认命令..."
            echo "CMD [\"npm\", \"start\"]" >> Dockerfile
          fi
          
          echo "Dockerfile验证完成，最终内容:"
          cat Dockerfile
        shell: bash

      # 使用AI生成的Dockerfile构建镜像
      - name: 构建AI生成的Dockerfile
        if: steps.project-detection.outputs.use_existing_dockerfile == 'false'
        id: build-ai-dockerfile
        continue-on-error: true
        uses: docker/build-push-action@v4
        with:
          context: ./src
          push: true
          tags: ${{ github.event.inputs.registry }}/${{ github.event.inputs.image_name }}:${{ github.event.inputs.image_tag }}
          # 禁用缓存配置
          no-cache: true

      # 处理AI生成的Dockerfile构建失败
      - name: 处理AI Dockerfile构建失败
        if: steps.project-detection.outputs.use_existing_dockerfile == 'false' && steps.build-ai-dockerfile.outcome == 'failure'
        run: |
          cd src
          echo "AI生成的Dockerfile构建失败，尝试修复..."
          
          # 保存构建日志
          echo "构建失败日志:" > ../build_error.txt
          echo "-----------------------------------" >> ../build_error.txt
          
          # 通过检查原始Dockerfile来分析可能的问题
          echo "分析Dockerfile潜在问题:" >> ../build_error.txt
          
          # 检查基本问题
          if ! grep -q "FROM" Dockerfile; then
            echo "- 缺少FROM指令，无法确定基础镜像" >> ../build_error.txt
          fi
          
          if ! grep -q "COPY\|ADD" Dockerfile; then
            echo "- 没有COPY或ADD指令，没有将应用代码复制到镜像中" >> ../build_error.txt
          fi
          
          if ! grep -q "CMD\|ENTRYPOINT" Dockerfile; then
            echo "- 没有CMD或ENTRYPOINT指令，无法确定启动命令" >> ../build_error.txt
          fi
          
          # 检查常见Node.js项目问题
          if [ -f "package.json" ]; then
            if grep -q "\"start\":" package.json && ! grep -q "npm start\|yarn start\|node " Dockerfile; then
              echo "- package.json中定义了start脚本，但Dockerfile中没有使用它" >> ../build_error.txt
            fi
            
            if [ -f "yarn.lock" ] && ! grep -q "yarn" Dockerfile; then
              echo "- 项目使用yarn但Dockerfile中可能使用了npm" >> ../build_error.txt
            fi
          fi
          
          # 检查常见Python项目问题
          if [ -f "requirements.txt" ]; then
            if ! grep -q "pip install\|pip3 install" Dockerfile; then
              echo "- 没有安装Python依赖，应该添加RUN pip install -r requirements.txt" >> ../build_error.txt
            fi
          fi
          
          # 提供修复建议
          echo "-----------------------------------" >> ../build_error.txt
          echo "修复建议:" >> ../build_error.txt
          echo "1. 确保使用正确的基础镜像" >> ../build_error.txt
          echo "2. 确保正确安装所有依赖" >> ../build_error.txt
          echo "3. 确保COPY或ADD命令复制了所有必要的文件" >> ../build_error.txt
          echo "4. 提供正确的CMD或ENTRYPOINT启动命令" >> ../build_error.txt
          echo "5. 如使用多阶段构建，确保阶段引用正确" >> ../build_error.txt
          
          # 将构建错误反馈添加到下一次AI生成的提示中
          BUILD_ERROR_FEEDBACK=$(cat ../build_error.txt)
          echo "BUILD_ERROR_FEEDBACK<<EOF" >> $GITHUB_ENV
          echo "$BUILD_ERROR_FEEDBACK" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          
          # 标记需要重试
          echo "需要重新生成Dockerfile并修复问题"
          exit 1  # 构建失败，需要后续步骤重试处理
        shell: bash

      # 使用项目自带Dockerfile构建
      - name: 使用项目自带Dockerfile构建
        if: steps.project-detection.outputs.use_existing_dockerfile == 'true'
        uses: docker/build-push-action@v4
        with:
          context: ./src
          push: true
          tags: ${{ github.event.inputs.registry }}/${{ github.event.inputs.image_name }}:${{ github.event.inputs.image_tag }}
          # 禁用缓存配置，避免错误
          no-cache: true
          # cache-from: type=gha
          # cache-to: type=gha,mode=max

      # 构建失败后，重新尝试AI生成和构建
      - name: 重新尝试AI生成和构建
        if: steps.build-ai-dockerfile.outcome == 'failure' && steps.project-detection.outputs.use_existing_dockerfile == 'false'
        uses: docker/build-push-action@v4
        with:
          context: ./src
          push: true
          tags: ${{ github.event.inputs.registry }}/${{ github.event.inputs.image_name }}:${{ github.event.inputs.image_tag }}
          no-cache: true

      # 构建完成后通知
      - name: 通知构建完成
        if: ${{ success() && github.event.inputs.callback_url != '' }}
        run: |
          # 保存Dockerfile的副本，用于通知
          if [ -f "src/Dockerfile" ]; then
            cp src/Dockerfile ./dockerfile_used.txt
          fi
          
          # 确定是用AI生成还是使用现有的Dockerfile
          if [ "${{ steps.project-detection.outputs.use_existing_dockerfile }}" == "true" ]; then
            DOCKERFILE_SOURCE="使用项目自带的Dockerfile"
          else
            DOCKERFILE_SOURCE="由AI自动生成Dockerfile"
          fi
          
          # 发送成功通知
          curl -X POST "${{ github.event.inputs.callback_url }}" \
            -H "Content-Type: application/json" \
            -d "{
              \"status\": \"success\",
              \"image\": \"${{ github.event.inputs.registry }}/${{ github.event.inputs.image_name }}:${{ github.event.inputs.image_tag }}\",
              \"repo_url\": \"${{ github.event.inputs.repo_url }}\",
              \"branch\": \"${{ github.event.inputs.branch }}\",
              \"build_id\": \"${{ github.run_id }}\",
              \"dockerfile_source\": \"${DOCKERFILE_SOURCE}\",
              \"ai_option\": \"${{ github.event.inputs.ai_options }}\"
            }"
        shell: bash

      # 构建失败后通知
      - name: 通知构建失败
        if: ${{ failure() && github.event.inputs.callback_url != '' }}
        run: |
          # 如果生成了Dockerfile但构建失败，提供Dockerfile内容
          DOCKERFILE_CONTENT=""
          if [ -f "src/Dockerfile" ]; then
            DOCKERFILE_CONTENT=$(cat src/Dockerfile | base64 -w 0)
          fi
          
          # 添加构建错误信息（如果有）
          BUILD_ERROR=""
          if [ -f "build_error.txt" ]; then
            BUILD_ERROR=$(cat build_error.txt | base64 -w 0)
          fi
          
          # 发送失败通知
          curl -X POST "${{ github.event.inputs.callback_url }}" \
            -H "Content-Type: application/json" \
            -d "{
              \"status\": \"failed\",
              \"repo_url\": \"${{ github.event.inputs.repo_url }}\",
              \"branch\": \"${{ github.event.inputs.branch }}\",
              \"build_id\": \"${{ github.run_id }}\",
              \"dockerfile_content_base64\": \"${DOCKERFILE_CONTENT}\",
              \"build_error_base64\": \"${BUILD_ERROR}\"
            }" 