name: Budiu 智能构建部署

on:
  workflow_dispatch:
    inputs:
      repo_url:
        description: '代码仓库地址 (GitHub或Gitee)'
        required: true
      branch:
        description: '分支名称'
        default: 'main'
        required: true
      image_name:
        description: '镜像名称'
        required: true
      image_tag:
        description: '镜像标签'
        default: 'latest'
        required: true
      registry:
        description: '镜像仓库地址'
        default: 'docker.io'
        required: true
      callback_url:
        description: '回调通知URL'
        required: false
      docker_auth:
        description: 'Docker认证(格式:username:password)'
        required: true
      ai_options:
        description: 'AI优化选项(size|security|speed)'
        default: 'size'
        required: false
      repo_token:
        description: '仓库访问令牌(私有仓库需要)'
        required: false

# 权限设置 - 包含AI访问
permissions:
  contents: write
  id-token: write

jobs:
  build-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: 配置初始化
        run: echo "开始Budiu智能构建部署流程..."

      - name: 检查输入参数
        run: |
          echo "代码仓库: ${{ github.event.inputs.repo_url }}"
          echo "分支: ${{ github.event.inputs.branch }}"
          echo "镜像名称: ${{ github.event.inputs.image_name }}"
          echo "镜像标签: ${{ github.event.inputs.image_tag }}"
          echo "镜像仓库: ${{ github.event.inputs.registry }}"

      - name: 克隆源代码
        run: |
          repo_url="${{ github.event.inputs.repo_url }}"
          repo_token="${{ github.event.inputs.repo_token }}"
          branch="${{ github.event.inputs.branch }}"
          
          if [ -n "$repo_token" ]; then
            auth_repo_url=$(echo $repo_url | sed "s/https:\/\//https:\/\/$repo_token@/")
            git clone --depth 1 -b $branch $auth_repo_url src || git clone --depth 1 $auth_repo_url src
          else
            git clone --depth 1 -b $branch $repo_url src || git clone --depth 1 $repo_url src
          fi
          
          if [ ! -d "src" ]; then
            echo "克隆失败，请检查仓库地址和分支名称"
            exit 1
          fi

      - name: 登录镜像仓库
        run: |
          DOCKER_AUTH="${{ github.event.inputs.docker_auth }}"
          DOCKER_USERNAME=$(echo $DOCKER_AUTH | cut -d':' -f1)
          DOCKER_PASSWORD=$(echo $DOCKER_AUTH | cut -d':' -f2-)
          
          echo $DOCKER_PASSWORD | docker login ${{ github.event.inputs.registry }} -u $DOCKER_USERNAME --password-stdin

      - name: 设置Docker Buildx
        uses: docker/setup-buildx-action@v2
        with:
          install: true

      # 项目预检测
      - name: 项目预检测
        id: project-detection
        run: |
          cd src
          
          # 检查是否存在自定义Dockerfile
          if [ -f "Dockerfile" ]; then
            echo "检测到自定义Dockerfile，将使用项目已有的Dockerfile"
            echo "use_existing_dockerfile=true" >> $GITHUB_OUTPUT
          else
            echo "未检测到Dockerfile，将使用AI生成"
            echo "use_existing_dockerfile=false" >> $GITHUB_OUTPUT
            
            # 回到工作目录保存项目信息
            cd ..
            
            # 收集项目信息
            echo "项目结构:" > "project_info.txt"
            find src -type f -not -path "*/\.*" | sort >> "project_info.txt"
            
            # 读取根目录文件
            echo "根目录文件列表:" >> "project_info.txt"
            ls -la src/ >> "project_info.txt"
            
            # 读取README文件
            if [ -f "src/README.md" ]; then
              echo "README.md内容:" >> "project_info.txt"
              cat src/README.md >> "project_info.txt"
            fi
          fi
        shell: bash

      # 深度项目分析
      - name: 深度项目分析
        if: steps.project-detection.outputs.use_existing_dockerfile == 'false'
        run: |
          # 在工作目录创建分析文件
          echo "进行深度项目分析..." > "project_analysis.txt"
          
          # 分析项目目录结构
          find src -type f -not -path "*/\.*" -not -path "*/node_modules/*" | sort >> "project_analysis.txt"
          
          # 检测主要技术栈
          if [ -f "src/package.json" ]; then
            echo "检测到Node.js项目" >> "project_analysis.txt"
            echo "package.json内容:" >> "project_analysis.txt"
            cat src/package.json >> "project_analysis.txt"
          elif [ -f "src/requirements.txt" ]; then
            echo "检测到Python项目" >> "project_analysis.txt"
            cat src/requirements.txt >> "project_analysis.txt"
          elif [ -f "src/pom.xml" ]; then
            echo "检测到Java项目" >> "project_analysis.txt"
            cat src/pom.xml >> "project_analysis.txt"
          fi
        shell: bash

      # 准备AI提示
      - name: 准备AI提示
        if: steps.project-detection.outputs.use_existing_dockerfile == 'false'
        id: prepare-prompt
        run: |
          # 确保在工作目录而非src目录中操作
          echo "准备AI提示内容..."
          echo "请先详细分析并说明这是什么类型的项目，包括：" > prompt.txt
          echo "1. 项目的主要编程语言和技术栈" >> prompt.txt
          echo "2. 项目的主要功能和用途" >> prompt.txt
          echo "3. 项目的架构特点和组件结构" >> prompt.txt
          echo "4. 项目的依赖管理方式和主要依赖" >> prompt.txt
          echo "" >> prompt.txt
          echo "在完成上述项目分析后，请基于分析结果为该项目创建最合适的Dockerfile:" >> prompt.txt
          echo "1. 根据项目特点选择最合适的基础镜像" >> prompt.txt
          echo "2. 构建与运行流程根据项目特性灵活设计" >> prompt.txt
          echo "3. 文件结构和启动命令根据项目规范自行确定" >> prompt.txt
          echo "4. 请完全基于项目实际需求进行设计，不受外部建议限制" >> prompt.txt
          
          # 根据优化选项提供参考信息
          AI_OPTION="${{ github.event.inputs.ai_options }}"
          if [ "$AI_OPTION" == "size" ] || [ -z "$AI_OPTION" ]; then
            echo "参考方向：可以考虑镜像体积优化" >> prompt.txt
          elif [ "$AI_OPTION" == "security" ]; then
            echo "参考方向：可以考虑安全性优化" >> prompt.txt
          elif [ "$AI_OPTION" == "speed" ]; then
            echo "参考方向：可以考虑构建和运行速度优化" >> prompt.txt
          fi
          
          # 添加收集的项目信息，确保文件存在再读取
          echo "项目信息:" >> prompt.txt
          if [ -f "project_info.txt" ]; then
            cat project_info.txt >> prompt.txt
          else
            echo "项目结构信息:" >> prompt.txt
            # 创建简单的项目结构信息作为备用
            find src -type f -not -path "*/\.*" -not -path "*/node_modules/*" | sort >> prompt.txt
            echo "当前工作目录文件:" >> prompt.txt
            ls -la src/ >> prompt.txt
          fi
          
          if [ -f "project_analysis.txt" ]; then
            cat project_analysis.txt >> prompt.txt
          else
            echo "深入项目分析:" >> prompt.txt
            
            # 检测主要技术栈
            if [ -f "src/package.json" ]; then
              echo "检测到package.json:" >> prompt.txt
              cat src/package.json >> prompt.txt
            elif [ -f "src/requirements.txt" ]; then
              echo "检测到requirements.txt:" >> prompt.txt
              cat src/requirements.txt >> prompt.txt
            elif [ -f "src/pom.xml" ]; then
              echo "检测到pom.xml:" >> prompt.txt
              cat src/pom.xml >> prompt.txt
            elif [ -f "src/go.mod" ]; then
              echo "检测到go.mod:" >> prompt.txt
              cat src/go.mod >> prompt.txt
            fi
            
            # 检测常见配置文件
            for config_file in src/Dockerfile.* src/docker-compose.* src/.dockerignore src/README.md src/docs/README.md; do
              if [ -f "$config_file" ]; then
                echo "检测到配置文件 $config_file:" >> prompt.txt
                cat "$config_file" >> prompt.txt
              fi
            done
          fi

      # 使用讯飞星火AI分析项目并生成Dockerfile
      - name: 使用讯飞星火AI分析项目并生成Dockerfile
        if: steps.project-detection.outputs.use_existing_dockerfile == 'false'
        id: generate-dockerfile
        run: |
          # 获取提示内容
          echo "使用讯飞星火AI先分析项目类型，再生成Dockerfile..."
          
          # API认证和请求参数
          SPARK_API_PASSWORD="${{ secrets.SPARK_API_PASSWORD }}"
          AUTH_URL="https://spark-api-open.xf-yun.com/v1/chat/completions"
          
          # 确保密钥存在
          if [ -z "$SPARK_API_PASSWORD" ]; then
            echo "错误: 未设置SPARK_API_PASSWORD密钥"
            exit 1
          fi
          
          # 准备请求体JSON
          PROMPT_CONTENT=$(cat "prompt.txt" | sed 's/"/\\"/g' | tr '\n' ' ')
          echo '{
            "model": "lite",
            "user": "github-actions-user",
            "messages": [
              {
                "role": "user",
                "content": "'$PROMPT_CONTENT'"
              }
            ],
            "temperature": 0.5,
            "max_tokens": 4096,
            "stream": false
          }' > "spark_request.json"
          
          # 发送API请求
          curl -s -X POST "$AUTH_URL" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $SPARK_API_PASSWORD" \
            -d @"spark_request.json" > "ai_response.json"
          
          # 检查API响应
          if grep -q "\"error\":" "ai_response.json"; then
            echo "API返回错误:"
            cat "ai_response.json"
            exit 1
          fi
          
          # 调试信息：显示原始响应
          echo "AI响应内容："
          cat "ai_response.json"
          
          # 从响应中提取AI分析和Dockerfile内容
          if jq -e '.choices[0].message.content' "ai_response.json" > /dev/null 2>&1; then
            # 标准格式
            jq -r '.choices[0].message.content' "ai_response.json" > src/ai_analysis.txt
            
            # 保存项目分析部分到单独文件
            cat src/ai_analysis.txt | sed -n '/^```dockerfile/,$p' | sed '1d' > src/Dockerfile.raw
            cat src/ai_analysis.txt | sed '/^```dockerfile/,$d' > src/project_analysis_result.txt
            echo "项目分析结果:"
            cat src/project_analysis_result.txt
          elif jq -e '.payload.choices.text[0].content' "ai_response.json" > /dev/null 2>&1; then
            # 备用格式
            jq -r '.payload.choices.text[0].content' "ai_response.json" > src/ai_analysis.txt
            
            # 保存项目分析部分到单独文件
            cat src/ai_analysis.txt | sed -n '/^```dockerfile/,$p' | sed '1d' > src/Dockerfile.raw
            cat src/ai_analysis.txt | sed '/^```dockerfile/,$d' > src/project_analysis_result.txt
            echo "项目分析结果:"
            cat src/project_analysis_result.txt
          else
            echo "无法从API响应中提取内容，创建默认Dockerfile"
            echo "# 未能分析项目，使用默认配置" > src/project_analysis_result.txt
            echo "FROM node:14-alpine" > src/Dockerfile
            echo "WORKDIR /app" >> src/Dockerfile
            echo "COPY . ." >> src/Dockerfile
            echo "CMD [\"npm\", \"start\"]" >> src/Dockerfile
            exit 0
          fi
          
          # 进入src目录处理Dockerfile
          cd src
          
          # 确保输出文件存在
          touch Dockerfile.raw
          
          # 清理Dockerfile内容，移除markdown格式
          cat Dockerfile.raw | grep -v '^\s*```' | grep -v '^\s*$' > Dockerfile.tmp
          
          # 提取有效Dockerfile内容
          if grep -q "^FROM" Dockerfile.tmp; then
            grep -E "^(FROM|COPY|ADD|RUN|WORKDIR|ENV|ARG|EXPOSE|CMD|ENTRYPOINT|VOLUME|USER|ONBUILD|STOPSIGNAL|HEALTHCHECK|SHELL|#)" Dockerfile.tmp > Dockerfile
          else
            # 创建基本Dockerfile作为后备
            echo "未找到有效的Dockerfile指令，创建基本模板..."
            echo "FROM node:14-alpine" > Dockerfile
            echo "WORKDIR /app" >> Dockerfile
            echo "COPY . ." >> Dockerfile
            echo "RUN if [ -f \"package.json\" ]; then npm install; fi" >> Dockerfile
            echo "CMD [\"npm\", \"start\"]" >> Dockerfile
          fi
          
          echo "生成的Dockerfile内容:"
          cat Dockerfile

      # 查看AI生成的Dockerfile
      - name: 查看Dockerfile
        if: steps.project-detection.outputs.use_existing_dockerfile == 'false'
        run: |
          cd src
          echo "查看AI生成的Dockerfile内容..."
          
          # 显示Dockerfile内容但不修改
          if [ -f "Dockerfile" ]; then
            echo "Dockerfile内容:"
            cat Dockerfile
          else
            echo "警告: Dockerfile未生成或不存在"
          fi
        shell: bash

      # 使用AI生成的Dockerfile构建镜像
      - name: 构建AI生成的Dockerfile
        if: steps.project-detection.outputs.use_existing_dockerfile == 'false'
        id: build-ai-dockerfile
        continue-on-error: true
        uses: docker/build-push-action@v4
        with:
          context: ./src
          push: true
          tags: ${{ github.event.inputs.registry }}/${{ github.event.inputs.image_name }}:${{ github.event.inputs.image_tag }}
          # 禁用缓存配置
          no-cache: true

      # 记录AI生成的Dockerfile构建失败
      - name: 记录AI Dockerfile构建失败
        if: steps.project-detection.outputs.use_existing_dockerfile == 'false' && steps.build-ai-dockerfile.outcome == 'failure'
        run: |
          cd src
          echo "AI生成的Dockerfile构建失败，记录问题..."
          
          # 保存构建日志
          echo "构建失败日志:" > ../build_error.txt
          echo "-----------------------------------" >> ../build_error.txt
          
          # 记录Dockerfile内容
          if [ -f "Dockerfile" ]; then
            echo "当前Dockerfile内容:" >> ../build_error.txt
            cat Dockerfile >> ../build_error.txt
            echo "-----------------------------------" >> ../build_error.txt
          fi
          
          # 提供修复建议但不修改
          echo "可能的问题及建议:" >> ../build_error.txt
          echo "1. 基础镜像可能不兼容" >> ../build_error.txt
          echo "2. 依赖项安装可能有问题" >> ../build_error.txt
          echo "3. 文件复制路径可能不正确" >> ../build_error.txt
          echo "4. 启动命令可能不适用于当前项目" >> ../build_error.txt
          
          # 将构建错误反馈添加到环境变量中
          BUILD_ERROR_FEEDBACK=$(cat ../build_error.txt)
          echo "BUILD_ERROR_FEEDBACK<<EOF" >> $GITHUB_ENV
          echo "$BUILD_ERROR_FEEDBACK" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          
          echo "需要向AI提供更详细的项目分析信息"
          exit 1  # 构建失败，需要后续步骤处理
        shell: bash

      # 使用项目自带Dockerfile构建
      - name: 使用项目自带Dockerfile构建
        if: steps.project-detection.outputs.use_existing_dockerfile == 'true'
        uses: docker/build-push-action@v4
        with:
          context: ./src
          push: true
          tags: ${{ github.event.inputs.registry }}/${{ github.event.inputs.image_name }}:${{ github.event.inputs.image_tag }}
          # 禁用缓存配置，避免错误
          no-cache: true
          # cache-from: type=gha
          # cache-to: type=gha,mode=max

      # 构建失败后，重新尝试AI生成和构建
      - name: 重新尝试AI生成和构建
        if: steps.build-ai-dockerfile.outcome == 'failure' && steps.project-detection.outputs.use_existing_dockerfile == 'false'
        uses: docker/build-push-action@v4
        with:
          context: ./src
          push: true
          tags: ${{ github.event.inputs.registry }}/${{ github.event.inputs.image_name }}:${{ github.event.inputs.image_tag }}
          no-cache: true

      # 构建完成后通知
      - name: 通知构建完成
        if: ${{ success() && github.event.inputs.callback_url != '' }}
        run: |
          # 保存Dockerfile和项目分析的副本，用于通知
          if [ -f "src/Dockerfile" ]; then
            cp src/Dockerfile ./dockerfile_used.txt
          fi
          
          if [ -f "src/project_analysis_result.txt" ]; then
            cp src/project_analysis_result.txt ./project_analysis.txt
          fi
          
          # 确定是用AI生成还是使用现有的Dockerfile
          if [ "${{ steps.project-detection.outputs.use_existing_dockerfile }}" == "true" ]; then
            DOCKERFILE_SOURCE="使用项目自带的Dockerfile"
            PROJECT_ANALYSIS=""
          else
            DOCKERFILE_SOURCE="由AI自动生成Dockerfile"
            PROJECT_ANALYSIS=$(cat ./project_analysis.txt | base64 -w 0 || echo "")
          fi
          
          # 发送成功通知
          curl -X POST "${{ github.event.inputs.callback_url }}" \
            -H "Content-Type: application/json" \
            -d "{
              \"status\": \"success\",
              \"image\": \"${{ github.event.inputs.registry }}/${{ github.event.inputs.image_name }}:${{ github.event.inputs.image_tag }}\",
              \"repo_url\": \"${{ github.event.inputs.repo_url }}\",
              \"branch\": \"${{ github.event.inputs.branch }}\",
              \"build_id\": \"${{ github.run_id }}\",
              \"dockerfile_source\": \"${DOCKERFILE_SOURCE}\",
              \"project_analysis_base64\": \"${PROJECT_ANALYSIS}\",
              \"ai_option\": \"${{ github.event.inputs.ai_options }}\"
            }"
        shell: bash

      # 构建失败后通知
      - name: 通知构建失败
        if: ${{ failure() && github.event.inputs.callback_url != '' }}
        run: |
          # 如果生成了Dockerfile但构建失败，提供Dockerfile内容
          DOCKERFILE_CONTENT=""
          if [ -f "src/Dockerfile" ]; then
            DOCKERFILE_CONTENT=$(cat src/Dockerfile | base64 -w 0)
          fi
          
          # 提供项目分析内容
          PROJECT_ANALYSIS=""
          if [ -f "src/project_analysis_result.txt" ]; then
            PROJECT_ANALYSIS=$(cat src/project_analysis_result.txt | base64 -w 0)
          fi
          
          # 添加构建错误信息（如果有）
          BUILD_ERROR=""
          if [ -f "build_error.txt" ]; then
            BUILD_ERROR=$(cat build_error.txt | base64 -w 0)
          fi
          
          # 发送失败通知
          curl -X POST "${{ github.event.inputs.callback_url }}" \
            -H "Content-Type: application/json" \
            -d "{
              \"status\": \"failed\",
              \"repo_url\": \"${{ github.event.inputs.repo_url }}\",
              \"branch\": \"${{ github.event.inputs.branch }}\",
              \"build_id\": \"${{ github.run_id }}\",
              \"dockerfile_content_base64\": \"${DOCKERFILE_CONTENT}\",
              \"project_analysis_base64\": \"${PROJECT_ANALYSIS}\",
              \"build_error_base64\": \"${BUILD_ERROR}\"
            }" 