name: Build and Deploy

on:
  workflow_dispatch:
    inputs:
      repo_url:
        description: '代码仓库地址 (GitHub或Gitee)'
        required: true
      branch:
        description: '分支名称'
        default: 'main'
        required: true
      image_name:
        description: '镜像名称'
        required: true
      image_tag:
        description: '镜像标签'
        default: 'latest'
        required: true
      registry:
        description: '镜像仓库地址'
        default: 'docker.io'
        required: true
      callback_url:
        description: '回调通知URL'
        required: false
      docker_username:
        description: 'Docker仓库用户名'
        required: true
      docker_password:
        description: 'Docker仓库密码/令牌'
        required: true
      repo_token:
        description: '仓库访问令牌(私有仓库需要)'
        required: false
      dockerfile_path:
        description: 'Dockerfile路径（相对于仓库根目录，留空使用自动检测）'
        required: false
      build_args:
        description: '构建参数（格式: KEY1=VALUE1,KEY2=VALUE2）'
        required: false
      build_platforms:
        description: '构建平台（如：linux/amd64,linux/arm64）'
        default: 'linux/amd64'
        required: true
      build_context:
        description: '构建上下文（相对于仓库根目录）'
        default: '.'
        required: true

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: 检查输入参数
        run: |
          echo "代码仓库: ${{ github.event.inputs.repo_url }}"
          echo "分支: ${{ github.event.inputs.branch }}"
          echo "镜像名称: ${{ github.event.inputs.image_name }}"
          echo "镜像标签: ${{ github.event.inputs.image_tag }}"
          echo "镜像仓库: ${{ github.event.inputs.registry }}"
          echo "构建平台: ${{ github.event.inputs.build_platforms }}"
          echo "构建上下文: ${{ github.event.inputs.build_context }}"
          
          if [ -n "${{ github.event.inputs.dockerfile_path }}" ]; then
            echo "使用指定Dockerfile: ${{ github.event.inputs.dockerfile_path }}"
          else
            echo "将自动检测Dockerfile"
          fi

      - name: 克隆源代码
        run: |
          repo_url="${{ github.event.inputs.repo_url }}"
          repo_token="${{ github.event.inputs.repo_token }}"
          branch="${{ github.event.inputs.branch }}"
          
          # 尝试自动检测默认分支
          if [ "$branch" = "main" ] || [ "$branch" = "master" ]; then
            echo "尝试自动检测默认分支..."
            
            if [[ $repo_url == *github.com* ]]; then
              repo_path=$(echo $repo_url | sed -E 's/https:\/\/github.com\/|git@github.com://;s/.git$//')
              default_branch=$(curl -s https://api.github.com/repos/$repo_path | grep -o '"default_branch": "[^"]*' | cut -d'"' -f4)
            fi
            
            if [ -n "$default_branch" ]; then
              echo "自动检测到默认分支: $default_branch"
              branch=$default_branch
            fi
          fi
          
          echo "最终使用分支: $branch"
          
          # 处理私有仓库的身份验证
          if [ -n "$repo_token" ]; then
            # GitHub 仓库
            if [[ $repo_url == *github.com* ]]; then
              auth_repo_url=$(echo $repo_url | sed "s/https:\/\//https:\/\/$repo_token@/")
              git clone --depth 1 -b $branch $auth_repo_url src || git clone --depth 1 $auth_repo_url src
            
            # Gitee 仓库
            elif [[ $repo_url == *gitee.com* ]]; then
              auth_repo_url=$(echo $repo_url | sed "s/https:\/\//https:\/\/$repo_token@/")
              git clone --depth 1 -b $branch $auth_repo_url src || git clone --depth 1 $auth_repo_url src
            
            else
              echo "尝试使用令牌进行克隆"
              auth_repo_url=$(echo $repo_url | sed "s/https:\/\//https:\/\/$repo_token@/")
              git clone --depth 1 -b $branch $auth_repo_url src || git clone --depth 1 $auth_repo_url src
            fi
          else
            # 公开仓库，无需令牌
            git clone --depth 1 -b $branch $repo_url src || git clone --depth 1 $repo_url src
          fi
          
          if [ ! -d "src" ]; then
            echo "克隆失败，请检查仓库地址和分支名称是否正确"
            exit 1
          fi
          
          # 设置构建上下文路径
          build_context="${{ github.event.inputs.build_context }}"
          if [ "$build_context" != "." ]; then
            echo "使用自定义构建上下文: $build_context"
            if [ ! -d "src/$build_context" ]; then
              echo "警告：指定的构建上下文目录不存在，将使用仓库根目录"
              build_context="."
            fi
          fi
        shell: bash

      # 检查是否存在Dockerfile并处理
      - name: 检查Dockerfile
        id: dockerfile-check
        run: |
          cd src
          
          # 确定Dockerfile路径
          DOCKERFILE_PATH="${{ github.event.inputs.dockerfile_path }}"
          
          # 如果没有指定Dockerfile，则查找默认位置
          if [ -z "$DOCKERFILE_PATH" ]; then
            if [ -f "Dockerfile" ]; then
              DOCKERFILE_PATH="Dockerfile"
            elif [ -f "docker/Dockerfile" ]; then
              DOCKERFILE_PATH="docker/Dockerfile"
            elif [ -f ".docker/Dockerfile" ]; then
              DOCKERFILE_PATH=".docker/Dockerfile"
            else
              # 没有找到Dockerfile，需要创建一个
              echo "未找到Dockerfile，将创建基本的Dockerfile"
              DOCKERFILE_PATH="Dockerfile.generated"
              
              # 检测项目类型并生成适当的Dockerfile
              if [ -f "package.json" ]; then
                echo "检测到Node.js项目，创建Node.js Dockerfile"
                
                # 检查是否有构建脚本
                HAS_BUILD_SCRIPT=$(grep -o '"build"' package.json || echo "")
                
                if [ -n "$HAS_BUILD_SCRIPT" ]; then
                  # 前端项目使用多阶段构建
                  cat > $DOCKERFILE_PATH <<EOF
FROM node:16-alpine AS builder
RUN apk add --no-cache git openssh
WORKDIR /app
COPY package*.json ./
RUN npm ci --legacy-peer-deps || npm install --legacy-peer-deps
COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=builder /app/build /usr/share/nginx/html
# 如果使用Vue，取消下面注释
# COPY --from=builder /app/dist /usr/share/nginx/html
RUN echo 'server { listen 80; location / { root /usr/share/nginx/html; index index.html; try_files \$uri \$uri/ /index.html; } }' > /etc/nginx/conf.d/default.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
EOF
                else
                  # 后端Node.js项目
                  cat > $DOCKERFILE_PATH <<EOF
FROM node:16-alpine
RUN apk add --no-cache git openssh
WORKDIR /app
COPY package*.json ./
RUN npm ci --legacy-peer-deps || npm install --legacy-peer-deps
COPY . .
EXPOSE 3000
CMD ["npm", "start"]
EOF
                fi
                
              elif [ -f "requirements.txt" ] || [ -f "setup.py" ]; then
                echo "检测到Python项目，创建Python Dockerfile"
                cat > $DOCKERFILE_PATH <<EOF
FROM python:3.9-slim
RUN apt-get update && apt-get install -y git && apt-get clean
WORKDIR /app
COPY requirements.txt* setup.py* ./
RUN pip install --no-cache-dir -r requirements.txt 2>/dev/null || pip install --no-cache-dir -e . 2>/dev/null || echo "依赖安装可能不完整"
COPY . .
EXPOSE 8000
CMD ["python", "app.py"]
EOF
              
              elif [ -f "pom.xml" ] || [ -f "build.gradle" ]; then
                echo "检测到Java项目，创建Java Dockerfile"
                cat > $DOCKERFILE_PATH <<EOF
FROM maven:3.8-openjdk-11-slim AS builder
RUN apt-get update && apt-get install -y git && apt-get clean
WORKDIR /app
COPY . .
RUN mvn package -DskipTests

FROM openjdk:11-jre-slim
WORKDIR /app
COPY --from=builder /app/target/*.jar ./app.jar
EXPOSE 8080
CMD ["java", "-jar", "app.jar"]
EOF
              
              else
                echo "未检测到特定项目类型，创建通用Dockerfile"
                cat > $DOCKERFILE_PATH <<EOF
FROM nginx:alpine
COPY . /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
EOF
              fi
            fi
          fi
          
          # 验证Dockerfile是否存在
          if [ ! -f "$DOCKERFILE_PATH" ]; then
            echo "错误：指定的Dockerfile路径 ($DOCKERFILE_PATH) 不存在"
            exit 1
          fi
          
          echo "使用Dockerfile: $DOCKERFILE_PATH"
          echo "dockerfile=$DOCKERFILE_PATH" >> $GITHUB_OUTPUT
          
          # 显示Dockerfile内容
          echo "------------Dockerfile内容------------"
          cat $DOCKERFILE_PATH
          echo "------------------------------------"
        shell: bash

      # 设置Docker Buildx
      - name: 设置Docker Buildx
        uses: docker/setup-buildx-action@v2
        with:
          platforms: ${{ github.event.inputs.build_platforms }}

      # 登录Docker仓库
      - name: 登录镜像仓库
        uses: docker/login-action@v2
        with:
          registry: ${{ github.event.inputs.registry }}
          username: ${{ github.event.inputs.docker_username }}
          password: ${{ github.event.inputs.docker_password }}

      # 准备构建参数
      - name: 准备构建参数
        id: build-args
        run: |
          BUILD_ARGS="${{ github.event.inputs.build_args }}"
          BUILD_ARGS_JSON="{"
          
          # 处理自定义构建参数
          if [ -n "$BUILD_ARGS" ]; then
            IFS=',' read -ra ARG_PAIRS <<< "$BUILD_ARGS"
            for pair in "${ARG_PAIRS[@]}"; do
              IFS='=' read -ra KV <<< "$pair"
              if [ ${#KV[@]} -eq 2 ]; then
                BUILD_ARGS_JSON+="\"${KV[0]}\": \"${KV[1]}\","
              fi
            done
          fi
          
          # 添加默认构建参数
          BUILD_ARGS_JSON+="\"NODE_ENV\": \"production\"}"
          
          echo "build_args_json=$BUILD_ARGS_JSON" >> $GITHUB_OUTPUT
          echo "构建参数: $BUILD_ARGS_JSON"
        shell: bash

      # 使用Docker Buildx构建并推送镜像
      - name: 构建并推送Docker镜像
        uses: docker/build-push-action@v4
        with:
          context: ./src/${{ github.event.inputs.build_context }}
          file: ./src/${{ steps.dockerfile-check.outputs.dockerfile }}
          push: true
          tags: ${{ github.event.inputs.registry }}/${{ github.event.inputs.image_name }}:${{ github.event.inputs.image_tag }}
          platforms: ${{ github.event.inputs.build_platforms }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: ${{ steps.build-args.outputs.build_args_json }}
          provenance: false
          
      # 构建完成后通知
      - name: 通知构建完成
        if: ${{ success() && github.event.inputs.callback_url != '' }}
        run: |
          curl -X POST ${{ github.event.inputs.callback_url }} \
            -H "Content-Type: application/json" \
            -d '{
              "status": "success",
              "image": "${{ github.event.inputs.registry }}/${{ github.event.inputs.image_name }}:${{ github.event.inputs.image_tag }}",
              "repo_url": "${{ github.event.inputs.repo_url }}",
              "branch": "${{ github.event.inputs.branch }}",
              "build_id": "${{ github.run_id }}"
            }'
        shell: bash

      # 构建失败后通知
      - name: 通知构建失败
        if: ${{ failure() && github.event.inputs.callback_url != '' }}
        run: |
          curl -X POST ${{ github.event.inputs.callback_url }} \
            -H "Content-Type: application/json" \
            -d '{
              "status": "failed",
              "repo_url": "${{ github.event.inputs.repo_url }}",
              "branch": "${{ github.event.inputs.branch }}",
              "build_id": "${{ github.run_id }}"
            }'
        shell: bash 