name: Build and Deploy

on:
  workflow_dispatch:
    inputs:
      repo_url:
        description: '代码仓库地址 (GitHub或Gitee)'
        required: true
      branch:
        description: '分支名称'
        default: 'main'
        required: true
      image_name:
        description: '镜像名称'
        required: true
      image_tag:
        description: '镜像标签'
        default: 'latest'
        required: true
      registry:
        description: '镜像仓库地址'
        default: 'docker.io'
        required: true
      callback_url:
        description: '回调通知URL'
        required: false
      docker_username:
        description: 'Docker仓库用户名'
        required: true
      docker_password:
        description: 'Docker仓库密码/令牌'
        required: true
      repo_token:
        description: '仓库访问令牌(私有仓库需要)'
        required: false

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: 检查输入参数
        run: |
          echo "代码仓库: ${{ github.event.inputs.repo_url }}"
          echo "分支: ${{ github.event.inputs.branch }}"
          echo "镜像名称: ${{ github.event.inputs.image_name }}"
          echo "镜像标签: ${{ github.event.inputs.image_tag }}"
          echo "镜像仓库: ${{ github.event.inputs.registry }}"

      - name: 克隆源代码
        run: |
          repo_url="${{ github.event.inputs.repo_url }}"
          repo_token="${{ github.event.inputs.repo_token }}"
          branch="${{ github.event.inputs.branch }}"
          
          # 提取仓库信息
          echo "分析仓库URL: $repo_url"
          
          # 预处理URL，移除可能的.git后缀
          clean_url=$(echo "$repo_url" | sed 's/\.git$//')
          
          # 提取仓库所有者和名称
          if [[ $clean_url == *github.com* ]]; then
            repo_path=$(echo $clean_url | sed -E 's/.*github\.com\/([^\/]+\/[^\/]+).*/\1/')
            echo "提取的GitHub仓库路径: $repo_path"
          elif [[ $clean_url == *gitee.com* ]]; then
            repo_path=$(echo $clean_url | sed -E 's/.*gitee\.com\/([^\/]+\/[^\/]+).*/\1/')
            echo "提取的Gitee仓库路径: $repo_path"
          fi
          
          # 尝试自动检测分支
          # 1. 检查URL中是否包含分支信息
          if [[ $clean_url == */tree/* ]]; then
            auto_branch=$(echo $clean_url | sed -E 's/.*\/tree\/([^\/]+).*/\1/')
            echo "从URL路径检测到分支: $auto_branch"
            branch=$auto_branch
          elif [[ $clean_url == */blob/* ]]; then
            auto_branch=$(echo $clean_url | sed -E 's/.*\/blob\/([^\/]+).*/\1/')
            echo "从URL blob路径检测到分支: $auto_branch"
            branch=$auto_branch
          # 2. 如果是main或master，尝试通过API检测默认分支
          elif [ "$branch" = "main" ] || [ "$branch" = "master" ]; then
            echo "尝试自动检测默认分支..."
            
            if [[ $repo_url == *github.com* ]] && [ -n "$repo_path" ]; then
              default_branch=$(curl -s https://api.github.com/repos/$repo_path | grep -o '"default_branch": "[^"]*' | cut -d'"' -f4)
              
              if [ -n "$default_branch" ]; then
                echo "通过GitHub API检测到默认分支: $default_branch"
                branch=$default_branch
              fi
            fi
          fi
          
          echo "最终使用分支: $branch"
          
          # 处理私有仓库的身份验证
          if [ -n "$repo_token" ]; then
            # GitHub 仓库
            if [[ $repo_url == *github.com* ]]; then
              auth_repo_url=$(echo $repo_url | sed "s/https:\/\//https:\/\/$repo_token@/")
              git clone --depth 1 -b $branch $auth_repo_url src || git clone --depth 1 $auth_repo_url src
            
            # Gitee 仓库
            elif [[ $repo_url == *gitee.com* ]]; then
              auth_repo_url=$(echo $repo_url | sed "s/https:\/\//https:\/\/$repo_token@/")
              git clone --depth 1 -b $branch $auth_repo_url src || git clone --depth 1 $auth_repo_url src
            
            else
              echo "不支持的仓库类型，但尝试使用令牌进行克隆"
              auth_repo_url=$(echo $repo_url | sed "s/https:\/\//https:\/\/$repo_token@/")
              git clone --depth 1 -b $branch $auth_repo_url src || git clone --depth 1 $auth_repo_url src
            fi
          else
            # 公开仓库，无需令牌
            git clone --depth 1 -b $branch $repo_url src || git clone --depth 1 $repo_url src
          fi
          
          if [ ! -d "src" ]; then
            echo "克隆失败，请检查仓库地址和分支名称是否正确"
            exit 1
          fi
        shell: bash

      # 登录Docker仓库
      - name: 登录镜像仓库
        uses: docker/login-action@v2
        with:
          registry: ${{ github.event.inputs.registry }}
          username: ${{ github.event.inputs.docker_username }}
          password: ${{ github.event.inputs.docker_password }}

      # 设置 Cloud Native Buildpacks
      - name: 设置 Buildpacks
        uses: buildpacks/github-actions/setup-pack@v5.0.0

      # 项目预检测
      - name: 项目预检测
        id: project-detection
        run: |
          cd src
          
          # 检查是否存在自定义Dockerfile
          if [ -f "Dockerfile" ]; then
            echo "检测到自定义Dockerfile，将使用Docker构建"
            echo "use_docker=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # 检查项目类型
          if [ -f "package.json" ]; then
            echo "检测到Node.js项目"
            echo "project_type=nodejs" >> $GITHUB_OUTPUT
          elif [ -f "requirements.txt" ] || [ -f "setup.py" ] || [ -f "pyproject.toml" ]; then
            echo "检测到Python项目"
            echo "project_type=python" >> $GITHUB_OUTPUT
          elif [ -f "pom.xml" ] || [ -f "build.gradle" ]; then
            echo "检测到Java项目"
            echo "project_type=java" >> $GITHUB_OUTPUT
          elif [ -f "go.mod" ] || [ -f "main.go" ]; then
            echo "检测到Go项目"
            echo "project_type=go" >> $GITHUB_OUTPUT
          else
            echo "未检测到特定项目类型，将使用通用构建器"
            echo "project_type=generic" >> $GITHUB_OUTPUT
          fi
        shell: bash

      # 使用Docker构建自定义Dockerfile
      - name: Docker构建(自定义Dockerfile)
        if: steps.project-detection.outputs.use_docker == 'true'
        uses: docker/build-push-action@v4
        with:
          context: ./src
          push: true
          tags: ${{ github.event.inputs.registry }}/${{ github.event.inputs.image_name }}:${{ github.event.inputs.image_tag }}
          # 简化的缓存配置
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # 使用Buildpacks构建项目
      - name: 使用Buildpacks构建镜像
        if: steps.project-detection.outputs.use_docker != 'true'
        run: |
          cd src
          
          # 选择合适的构建器
          BUILDER="paketobuildpacks/builder:base"
          PROJECT_TYPE="${{ steps.project-detection.outputs.project_type }}"
          
          # 根据项目类型设置环境变量
          ENV_VARS=""
          if [ "$PROJECT_TYPE" == "nodejs" ]; then
            # Node.js项目特定配置
            ENV_VARS="--env BP_NODE_VERSION=16 --env NPM_CONFIG_LEGACY_PEER_DEPS=true"
            
            # 添加开发依赖安装支持
            ENV_VARS="$ENV_VARS --env BP_NODE_OPTIMIZE=false --env NODE_ENV=development"
            
            # 确保concurrently被全局安装
            ENV_VARS="$ENV_VARS --env BP_NODE_INSTALL_GLOBALS=concurrently"
            
            # 检查是否有build脚本
            if grep -q '"build"' package.json; then
              ENV_VARS="$ENV_VARS --env BP_NODE_RUN_SCRIPTS=build"
            fi
          elif [ "$PROJECT_TYPE" == "java" ]; then
            # Java项目特定配置
            ENV_VARS="--env BP_JAVA_VERSION=11"
          elif [ "$PROJECT_TYPE" == "python" ]; then
            # Python项目特定配置
            ENV_VARS="--env BP_PYTHON_VERSION=3.9"
          fi
          
          # 使用pack命令构建镜像
          echo "使用Buildpacks构建镜像中，这可能需要几分钟时间..."
          echo "构建命令: pack build ${{ github.event.inputs.registry }}/${{ github.event.inputs.image_name }}:${{ github.event.inputs.image_tag }} --builder $BUILDER $ENV_VARS --publish"
          
          # 执行构建
          pack build ${{ github.event.inputs.registry }}/${{ github.event.inputs.image_name }}:${{ github.event.inputs.image_tag }} \
            --builder $BUILDER \
            $ENV_VARS \
            --trust-builder \
            --publish
        shell: bash

      # 构建完成后通知
      - name: 通知构建完成
        if: ${{ success() && github.event.inputs.callback_url != '' }}
        run: |
          curl -X POST ${{ github.event.inputs.callback_url }} \
            -H "Content-Type: application/json" \
            -d '{
              "status": "success",
              "image": "${{ github.event.inputs.registry }}/${{ github.event.inputs.image_name }}:${{ github.event.inputs.image_tag }}",
              "repo_url": "${{ github.event.inputs.repo_url }}",
              "branch": "${{ github.event.inputs.branch }}",
              "build_id": "${{ github.run_id }}"
            }'
        shell: bash

      # 构建失败后通知
      - name: 通知构建失败
        if: ${{ failure() && github.event.inputs.callback_url != '' }}
        run: |
          curl -X POST ${{ github.event.inputs.callback_url }} \
            -H "Content-Type: application/json" \
            -d '{
              "status": "failed",
              "repo_url": "${{ github.event.inputs.repo_url }}",
              "branch": "${{ github.event.inputs.branch }}",
              "build_id": "${{ github.run_id }}"
            }'
        shell: bash 